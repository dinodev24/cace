#!/usr/bin/env python3
#-----------------------------------------------------------------------------
# cace_makeplot.py
#-----------------------------------------------------------------------------
# Plot routines for CACE using matplotlib
#-----------------------------------------------------------------------------

import re
import os
import matplotlib

from matplotlib.figure import Figure

# Warning: PIL Tk required, may not be in default install of python3.
# For Fedora, for example, need "yum install python-pillow-tk"

from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.backends.backend_agg import FigureCanvasAgg

from cace_gensim import twos_comp

#-----------------------------------------------------------------------------
# Given a plot record from a spec sheet and a full set of testbenches, generate
# a plot.  The name of the plot file and the vectors to plot, labels, legends,
# and so forth are all contained in the 'plotrec' dictionary.
#
# If run from a GUI then "parent" is a window passed by the caller that the
# plot will be drawn in.
#
# Returns the canvas record generated by matplotlib.
#-----------------------------------------------------------------------------

def cace_makeplot(dsheet, param, parent=None):

    if 'plot' not in param:
        return None
    else:
        plotrec = param['plot']

    if 'variables' not in param:
        variables = []
    else:
        variables = param['variables']

    if 'runtime_options' in dsheet:
        runtime_options = dsheet['runtime_options']
    else:
        runtime_options = None

    debug = False
    if runtime_options:
        if 'noplot' in runtime_options:
            if runtime_options['noplot']:
                return None
        if 'debug' in runtime_options:
            debug = runtime_options['debug']

    # Development:  For now, just take the results from the 1st testbench
    # All testbenches should have the same data, just with different sets
    # of conditions.  Multiple testbench data will be steps in the graph.

    numtbs = len(param['testbenches'])
    if numtbs > 1:
        print('Warning:  Plot is taken only from 1st of ' + str(numtbs) + ' testbenches.')
    elif numtbs == 0:
        print('Error:  Plot has no results.')

    tbzero = param['testbenches'][0]
    results = tbzero['results']

    binrex = re.compile(r'([0-9]*)\'([bodh])', re.IGNORECASE)
    # Organize data into plot lines according to formatting

    if 'type' in plotrec:
        plottype = plotrec['type']
    else:
        plottype = 'xyplot'

    # The 'format' record of the 'simulate' dictionary in the parameter
    # indicates how the simulation data should be formatted.  The first
    # two items were previously handled to generate the results vector,
    # so remove them, leaving only the names of the result columns.

    simdict = param['simulate']
    if 'format' in simdict:
        simformat = simdict['format'][2:]
    else:
        simformat = ['result']

    if plottype == 'histogram':
        xname = 'result'
    else:
        xname = plotrec['xaxis']

    # Find index of X data in results.  All results lines have the same
    # data, so pick up the number of items per result from the 1st entry.

    rlen = len(results[0])
    try:
        xidx = next(r for r in range(rlen) if simformat[r] == xname)
    except StopIteration:
        print('Plot error:  No signal ' + xname + ' recorded in format.')
        return None
                            
    # Find unique values of each variable (except results, traces, and iterations)
    traces = [0]
    bmatch = binrex.match(results[1][0])	# FIXME
    if bmatch:
        digits = bmatch.group(1)
        if digits == '':
            digits = len(results[2][0])
        else:
            digits = int(digits)
        cbase = bmatch.group(2)
        if cbase == 'b':
            base = 2
        elif cbase == 'o':
            base = 8
        elif cbase == 'd':
            base = 10
        else:
            base = 16
        binconv = [[base, digits]]
    else:
        binconv = [[]]

    if debug:
        print('Processing ' + str(rlen) + ' plot variables.')

    tracedicts = []
    for i in range(1, rlen):

        # results labeled 'iterations', 'result', 'trace', or 'time' are treated as plot vectors
        isvector = False
        if simformat[i] == 'iterations':
            isvector = True
        elif simformat[i] == 'result':
            isvector = True
        elif simformat[i] == 'time':
            isvector = True
        elif simformat[i].split('|')[0] == 'trace':
            isvector = True

        # Results whose labels are in the 'variables' list are treated as plot vectors
        if isvector == False:
            if variables:
                try:
                    varrec = next(item for item in variables if item['name'] == simformat[i])
                except StopIteration:
                    tracedicts.append([])
                else:
                    isvector = True
                    tracedicts.append(varrec)
        else:
            tracedicts.append([])

        # 'iterations' and 'time' are the x-axis variable, so don't add them to traces
        # (but maybe just check that xaxis name is not made into a trace?)
        if simformat[i] != 'iterations' and simformat[i] != 'time':
            traces.append(i)

        # Mark which items need converting from digital.  Format is verilog-like.  Use
        # a format width that is larger than the actual number of digits to force
        # unsigned conversion.

        bmatch = binrex.match(results[1][i])	# FIXME
        if bmatch:
            digits = bmatch.group(1)
            if digits == '':
                digits = len(results[2][i])
            else:
                digits = int(digits)
            cbase = bmatch.group(2)
            if cbase == 'b':
                base = 2
            elif cbase == 'o':
                base = 8
            elif cbase == 'd':
                base = 10
            else:
                base = 16
            binconv.append([base, digits])
        else:
            binconv.append([])
        
    # Support older method of declaring a digital vector
    if xname.split('|')[0] == 'digital':
        binconv[xidx] = [2, len(results[2][0])]

    # Which stepped variables (ignoring X axis variable) have more than one value?
    # watchsteps = list(i for i in range(1, rlen) if len(steps[i]) > 1 and i != xidx)
    watchsteps = []

    # Diagnostic
    # print("Stepped conditions are: ")
    # for j in watchsteps:
    #      print(results[0][j] + '  (' + str(len(steps[j])) + ' steps)')

    needconvert = False
    if xname.split('|')[0] == 'digital' or binconv[xidx] != []:
        needconvert = True

    # Collect results.  Make a separate record for each unique set of stepped conditions
    # encountered.  Record has (X, Y) vector and a list of conditions.
    pdata = {}

    # Limit the amount of data being processed.  NOTE:  This is a stupid-simple
    # way to do it and it needs much better handling;  e.g., import scipy and
    # resample to a constant time step.

    numpoints = len(results)
    if debug:
        print('Processing ' + str(numpoints) + ' data points.')
    if numpoints > 1000:
        stepsize = int(numpoints / 1000)
        if debug:
            print('Truncating data with step size ' + str(stepsize))
    else:
        stepsize = 1
        

    for idx in range(0, numpoints, stepsize):
        item = results[idx]
        if needconvert:
            base = binconv[xidx][0]
            digits = binconv[xidx][1]
            # Recast binary strings as integers
            # Watch for strings that have been cast to floats (need to find the source of this)
            if '.' in item[xidx]:
                item[xidx] = item[xidx].split('.')[0]
            a = int(item[xidx], base)
            b = twos_comp(a, digits)
            xvalue = b
        else:
            xvalue = item[xidx]

        slist = []
        for j in watchsteps:
             slist.append(item[j])
        istr = ','.join(slist)
        if istr not in pdata:
            stextlist = []
            for j in watchsteps:
                if results[1][j] == '':
                    stextlist.append(results[0][j] + '=' + item[j])
                else:
                    stextlist.append(results[0][j] + '=' + item[j] + ' ' + results[1][j])
            pdict = {}
            pdata[istr] = pdict
            pdict['xdata'] = []
            if stextlist:
                tracelegnd = False
            else:
                tracelegnd = True

            for i in traces:
                aname = 'ydata' + str(i)
                pdict[aname] = []
                alabel = 'ylabel' + str(i)
                tracename = results[0][i]
                if ':' in tracename:
                    tracename = tracename.split(':')[1]

                if results[1][i] != '' and not binrex.match(results[1][i]):
                    tracename += ' (' + results[1][i] + ')'

                pdict[alabel] = tracename

            pdict['sdata'] = ' '.join(stextlist)
        else:
            pdict = pdata[istr]
        pdict['xdata'].append(xvalue)

        for i in traces:
            # For each trace, convert the value from digital to integer if needed
            if binconv[i] != []:
                base = binconv[i][0]
                digits = binconv[i][1]
                a = int(item[i], base)
                b = twos_comp(a, digits)
                yvalue = b
            else:
                yvalue = item[i]

            aname = 'ydata' + str(i)
            pdict[aname].append(yvalue)

    fig = Figure()
    if parent == None:
        canvas = FigureCanvasAgg(fig)
    else:
        canvas = FigureCanvasTkAgg(fig, parent)

    # With no parent, just make one plot and put the legend off to the side.  The
    # 'extra artists' capability of print_figure will take care of the bounding box.
    # For display, prepare two subplots so that the legend takes up the space of the
    # second one.
    if parent == None:
        ax = fig.add_subplot(111)
    else:
        ax = fig.add_subplot(121)

    # fig.hold(True)
    for record in pdata:
        pdict = pdata[record]

        # Check if xdata is numeric
        try:
            test = float(pdict['xdata'][0])
        except ValueError:
            numeric = False
            xdata = [i for i in range(len(pdict['xdata']))]
        else:
            numeric = True
            xdata = list(map(float,pdict['xdata']))

        if plottype == 'histogram':
            ax.hist(xdata, histtype='barstacked', label=pdict['sdata'], stacked=True)
        else:
            for i in traces:
                aname = 'ydata' + str(i)
                alabl = 'ylabel' + str(i)
                ax.plot(xdata, pdict[aname], label=pdict[alabl] + ' ' + pdict['sdata'])
                # Diagnostic
                # print("Y values for " + aname + ": " + str(pdict[aname]))

        if not numeric:
            ax.set_xticks(xdata)
            ax.set_xticklabels(pdict['xdata'])

    if 'xlabel' in plotrec:
        if results[1][xidx] == '' or binrex.match(results[1][xidx]):
            ax.set_xlabel(plotrec['xlabel'])
        else:
            ax.set_xlabel(plotrec['xlabel'] + ' (' + results[1][xidx] + ')')
    else:
        # Automatically generate X axis label if not given alternate text
        xtext = results[0][xidx]
        if results[1][xidx] != '':
            xtext += ' (' + results[1][xidx] + ')'
        ax.set_xlabel(xtext)

    if 'ylabel' in plotrec:
        if results[1][0] == '' or binrex.match(results[1][0]):
            ax.set_ylabel(plotrec['ylabel'])
        else:
            ax.set_ylabel(plotrec['ylabel'] + ' (' + results[1][0] + ')')
    else:
        # Automatically generate Y axis label if not given alternate text
        ytext = results[0][0]
        if results[1][0] != '' or binrex.match(results[1][0]):
            ytext += ' (' + results[1][0] + ')'
        ax.set_ylabel(ytext)

    ax.grid(True)
    if watchsteps or tracelegnd:
        legnd = ax.legend(loc = 2, bbox_to_anchor = (1.05, 1), borderaxespad=0.)
    else:
        legnd = None

    if legnd:
        legnd.set_draggable(True)

    if parent == None:
        paths = dsheet['paths']
        simdir = paths['simulation']
        if 'filename' in plotrec:
            plotname = plotrec['filename']
        else:
            plotname = param['name'] + '.png'

        filename = os.path.join(simdir, plotname)

        # NOTE: print_figure only makes use of bbox_extra_artists if
        # bbox_inches is set to 'tight'.  This forces a two-pass method
        # that calculates the real maximum bounds of the figure.  Otherwise
        # the legend gets clipped.
        if legnd:
            canvas.print_figure(filename, bbox_inches = 'tight',
                        bbox_extra_artists = [legnd])
        else:
            canvas.print_figure(filename, bbox_inches = 'tight')

    return canvas
